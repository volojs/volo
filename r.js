/**
 * @license r.js Copyright (c) 2010, The Dojo Foundation All Rights Reserved.
 * Available via the MIT, GPL or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */

/*jslint nomen: false */
/*global require: true, process: false, global: false, logger: false, commonJs: false */
"use strict";

/*
 This file is an adapter file to allow RequireJS to run in node.
 If you are in the directory that contains the JS file you want node to
 run, then issue this command (assuming you want to run index.js):
 > node path/to/r.js index.js
*/

(function () {
    var fs = require("fs"),
        sys = require("sys"),
        cwd = process.cwd(),
        appFilePath = process.argv[2],
        isDebug = false,
        appDir;

    if (appFilePath === "debug") {
        isDebug = true;
        appFilePath = process.argv[3];
    }

    //Make sure path to app file is absolute.
    if (appFilePath.charAt(0) !== "/") {
        appFilePath = [cwd, appFilePath].join("/");
    }

    //Now get app directory.
    appDir = appFilePath.split("/");
    appDir.pop();
    appDir = appDir.join("/");

    //Create some temporary globals that will be removed by the injected file.
    global.__requireIsDebug = isDebug;
    global.__requireLog = sys.puts;
    global.__requireReadFile = function (path) {
        return fs.readFileSync(path) + '';
    };

    //dist.sh will inject the modified requireAdapter content as a string.
    process.compile("/**\n * @license RequireJS requireAdapter Copyright (c) 2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint nomen: false */\n/*global require: false, process: false, global: false, logger: false, commonJs: false */\n\n\"use strict\";\n\n/** vim: et:ts=4:sw=4:sts=4\n * @license RequireJS Copyright (c) 2004-2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n//laxbreak is true to allow build pragmas to change some statements.\n/*jslint plusplus: false, nomen: false, laxbreak: true, regexp: false */\n/*global window: false, document: false, navigator: false,\nsetTimeout: false, traceDeps: true, clearInterval: false, self: false,\nsetInterval: false, importScripts: false */\n\"use strict\";\n\nvar require;\n(function () {\n    //Change this version number for each release.\n    var version = \"0.14.2\",\n            empty = {}, s,\n            i, defContextName = \"_\", contextLoads = [],\n            scripts, script, rePkg, src, m, dataMain, cfg = {}, setReadyState,\n            readyRegExp = /^(complete|loaded)$/,\n            commentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg,\n            cjsRequireRegExp = /require\\([\"\']([\\w-_\\.\\/]+)[\"\']\\)/g,\n            main,\n            isBrowser = !!(typeof window !== \"undefined\" && navigator && document),\n            isWebWorker = !isBrowser && typeof importScripts !== \"undefined\",\n            ostring = Object.prototype.toString,\n            ap = Array.prototype,\n            aps = ap.slice, scrollIntervalId, req, baseElement,\n            defQueue = [], useInteractive = false, currentlyAddingScript;\n\n    function isFunction(it) {\n        return ostring.call(it) === \"[object Function]\";\n    }\n\n    //Check for an existing version of require. If so, then exit out. Only allow\n    //one version of require to be active in a page. However, allow for a require\n    //config object, just exit quickly if require is an actual function.\n    if (typeof require !== \"undefined\") {\n        if (isFunction(require)) {\n            return;\n        } else {\n            //assume it is a config object.\n            cfg = require;\n        }\n    }\n    \n    //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n    /**\n     * Calls a method on a plugin. The obj object should have two property,\n     * name: the name of the method to call on the plugin\n     * args: the arguments to pass to the plugin method.\n     */\n    function callPlugin(prefix, context, obj) {\n        //Call the plugin, or load it.\n        var plugin = s.plugins.defined[prefix], waiting;\n        if (plugin) {\n            plugin[obj.name].apply(null, obj.args);\n        } else {\n            //Put the call in the waiting call BEFORE requiring the module,\n            //since the require could be synchronous in some environments,\n            //like builds\n            waiting = s.plugins.waiting[prefix] || (s.plugins.waiting[prefix] = []);\n            waiting.push(obj);\n\n            //Load the module\n            req([\"require/\" + prefix], context.contextName);\n        }\n    }\n    //>>excludeEnd(\"requireExcludePlugin\");\n\n    /**\n     * Convenience method to call main for a require.def call that was put on\n     * hold in the defQueue.\n     */\n    function callDefMain(args, context) {\n        main.apply(req, args);\n        //Mark the module loaded. Must do it here in addition\n        //to doing it in require.def in case a script does\n        //not call require.def\n        context.loaded[args[0]] = true;\n    }\n\n    /**\n     * Used to set up package paths from a packagePaths or packages config object.\n     * @param {Object} packages the object to store the new package config\n     * @param {Array} currentPackages an array of packages to configure\n     * @param {String} [dir] a prefix dir to use.\n     */\n    function configurePackageDir(packages, currentPackages, dir) {\n        var i, location, pkgObj;\n        for (i = 0; (pkgObj = currentPackages[i]); i++) {\n            pkgObj = typeof pkgObj === \"string\" ? { name: pkgObj } : pkgObj;\n            location = pkgObj.location;\n\n            //Add dir to the path, but avoid paths that start with a slash\n            //or have a colon (indicates a protocol)\n            if (dir && (!location || (location.indexOf(\"/\") !== 0 && location.indexOf(\":\") === -1))) {\n                pkgObj.location = dir + \"/\" + (pkgObj.location || pkgObj.name);\n            }\n\n            //Normalize package paths.\n            pkgObj.location = pkgObj.location || pkgObj.name;\n            pkgObj.lib = pkgObj.lib || \"lib\";\n            pkgObj.main = pkgObj.main || \"main\";\n\n            packages[pkgObj.name] = pkgObj;\n        }\n    }\n\n    /**\n     * Resumes tracing of dependencies and then checks if everything is loaded.\n     */\n    function resume(context) {\n        var args, i, paused = s.paused;\n        if (context.scriptCount <= 0) {\n            //Synchronous envs will push the number below zero with the\n            //decrement above, be sure to set it back to zero for good measure.\n            //require() calls that also do not end up loading scripts could\n            //push the number negative too.\n            context.scriptCount = 0;\n\n            //Make sure any remaining defQueue items get properly processed.\n            while (defQueue.length) {\n                args = defQueue.shift();\n                if (args[0] === null) {\n                    req.onError(new Error(\'Mismatched anonymous require.def modules\'));\n                } else {\n                    callDefMain(args, context);\n                }\n            }\n\n            //Skip the resume if current context is in priority wait.\n            if (s.contexts[s.ctxName].config.priorityWait) {\n                return;\n            }\n\n            if (paused.length) {\n                for (i = 0; (args = paused[i]); i++) {\n                    req.checkDeps.apply(req, args);\n                }\n            }\n\n            req.checkLoaded(s.ctxName);\n        }\n    }\n\n    /**\n     * Main entry point.\n     *\n     * If the only argument to require is a string, then the module that\n     * is represented by that string is fetched for the appropriate context.\n     *\n     * If the first argument is an array, then it will be treated as an array\n     * of dependency string names to fetch. An optional function callback can\n     * be specified to execute when all of those dependencies are available.\n     */\n    require = function (deps, callback, contextName, relModuleName) {\n        var context, config;\n        if (typeof deps === \"string\" && !isFunction(callback)) {\n            //Just return the module wanted. In this scenario, the\n            //second arg (if passed) is just the contextName.\n            return require.get(deps, callback, contextName, relModuleName);\n        }\n        // Dependencies first\n        if (!require.isArray(deps)) {\n            // deps is a config object\n            config = deps;\n            if (require.isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = contextName;\n                contextName = arguments[3];\n            } else {\n                deps = [];\n            }\n        }\n        main(null, deps, callback, config, contextName);\n\n        //If the require call does not trigger anything new to load,\n        //then resume the dependency processing. Context will be undefined\n        //on first run of require.\n        context = s.contexts[(contextName || (config && config.context) || s.ctxName)];\n        if (context && context.scriptCount === 0) {\n            resume(context);\n        }\n        //Returning undefined for Spidermonky strict checking in Komodo\n        return undefined;\n    };\n\n    //Alias for caja compliance internally -\n    //specifically: \"Dynamically computed names should use require.async()\"\n    //even though this spec isn\'t really decided on.\n    //Since it is here, use this alias to make typing shorter.\n    req = require;\n\n    /**\n     * Any errors that require explicitly generates will be passed to this\n     * function. Intercept/override it if you want custom error handling.\n     * If you do override it, this method should *always* throw an error\n     * to stop the execution flow correctly. Otherwise, other weird errors\n     * will occur.\n     * @param {Error} err the error object.\n     */\n    req.onError = function (err) {\n        throw err;\n    };\n\n    /**\n     * The function that handles definitions of modules. Differs from\n     * require() in that a string for the module should be the first argument,\n     * and the function to execute after dependencies are loaded should\n     * return a value to define the module corresponding to the first argument\'s\n     * name.\n     */\n    req.def = function (name, deps, callback, contextName) {\n        var i, scripts, script, node = currentlyAddingScript;\n\n        //Allow for anonymous functions\n        if (typeof name !== \'string\') {\n            //Adjust args appropriately\n            contextName = callback;\n            callback = deps;\n            deps = name;\n            name = null;\n        }\n\n        //This module may not have dependencies\n        if (!req.isArray(deps)) {\n            contextName = callback;\n            callback = deps;\n            deps = [];\n        }\n\n        //If no name, and callback is a function, then figure out if it a\n        //CommonJS thing with dependencies.\n        if (!name && !deps.length && req.isFunction(callback)) {\n            //Remove comments from the callback string,\n            //look for require calls, and pull them into the dependencies.\n            callback\n                .toString()\n                .replace(commentRegExp, \"\")\n                .replace(cjsRequireRegExp, function (match, dep) {\n                    deps.push(dep);\n                });\n\n            //May be a CommonJS thing even without require calls, but still\n            //could use exports, and such, so always add those as dependencies.\n            //This is a bit wasteful for RequireJS modules that do not need\n            //an exports or module object, but erring on side of safety.\n            //REQUIRES the function to expect the CommonJS variables in the\n            //order listed below.\n            deps = [\"require\", \"exports\", \"module\"].concat(deps);\n        }\n\n        //If in IE 6-8 and hit an anonymous require.def call, do the interactive/\n        //currentlyAddingScript scripts stuff.\n        if (!name && useInteractive) {\n            scripts = document.getElementsByTagName(\'script\');\n            for (i = scripts.length - 1; i > -1 && (script = scripts[i]); i--) {\n                if (script.readyState === \'interactive\') {\n                    node = script;\n                    break;\n                }\n            }\n            if (!node) {\n                req.onError(new Error(\"ERROR: No matching script interactive for \" + callback));\n            }\n\n            name = node.getAttribute(\"data-requiremodule\");\n        }\n\n        //Always save off evaluating the def call until the script onload handler.\n        //This allows multiple modules to be in a file without prematurely\n        //tracing dependencies, and allows for anonymous module support,\n        //where the module name is not known until the script onload event\n        //occurs.\n        defQueue.push([name, deps, callback, null, contextName]);\n    };\n\n    main = function (name, deps, callback, config, contextName) {\n        //Grab the context, or create a new one for the given context name.\n        var context, newContext, loaded, pluginPrefix,\n            canSetContext, prop, newLength, outDeps, mods, paths, index, i,\n            deferMods, deferModArgs, lastModArg, waitingName, packages,\n            packagePaths;\n\n        contextName = contextName ? contextName : (config && config.context ? config.context : s.ctxName);\n        context = s.contexts[contextName];\n\n        if (name) {\n            //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n            // Pull off any plugin prefix.\n            index = name.indexOf(\"!\");\n            if (index !== -1) {\n                pluginPrefix = name.substring(0, index);\n                name = name.substring(index + 1, name.length);\n            } else {\n                //Could be that the plugin name should be auto-applied.\n                //Used by i18n plugin to enable anonymous i18n modules, but\n                //still associating the auto-generated name with the i18n plugin.\n                pluginPrefix = context.defPlugin[name];\n            }\n\n            //>>excludeEnd(\"requireExcludePlugin\");\n\n            //If module already defined for context, or already waiting to be\n            //evaluated, leave.\n            waitingName = context.waiting[name];\n            if (context && (context.defined[name] || (waitingName && waitingName !== ap[name]))) {\n                return;\n            }\n        }\n\n        if (contextName !== s.ctxName) {\n            //If nothing is waiting on being loaded in the current context,\n            //then switch s.ctxName to current contextName.\n            loaded = (s.contexts[s.ctxName] && s.contexts[s.ctxName].loaded);\n            canSetContext = true;\n            if (loaded) {\n                for (prop in loaded) {\n                    if (!(prop in empty)) {\n                        if (!loaded[prop]) {\n                            canSetContext = false;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (canSetContext) {\n                s.ctxName = contextName;\n            }\n        }\n\n        if (!context) {\n            newContext = {\n                contextName: contextName,\n                config: {\n                    waitSeconds: 7,\n                    baseUrl: s.baseUrl || \"./\",\n                    paths: {},\n                    packages: {}\n                },\n                waiting: [],\n                specified: {\n                    \"require\": true,\n                    \"exports\": true,\n                    \"module\": true\n                },\n                loaded: {},\n                scriptCount: 0,\n                urlFetched: {},\n                defPlugin: {},\n                defined: {},\n                modifiers: {}\n            };\n\n            //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n            if (s.plugins.newContext) {\n                s.plugins.newContext(newContext);\n            }\n            //>>excludeEnd(\"requireExcludePlugin\");\n\n            context = s.contexts[contextName] = newContext;\n        }\n\n        //If have a config object, update the context\'s config object with\n        //the config values.\n        if (config) {\n            //Make sure the baseUrl ends in a slash.\n            if (config.baseUrl) {\n                if (config.baseUrl.charAt(config.baseUrl.length - 1) !== \"/\") {\n                    config.baseUrl += \"/\";\n                }\n            }\n\n            //Save off the paths and packages since they require special processing,\n            //they are additive.\n            paths = context.config.paths;\n            packages = context.config.packages;\n\n            //Mix in the config values, favoring the new values over\n            //existing ones in context.config.\n            req.mixin(context.config, config, true);\n\n            //Adjust paths if necessary.\n            if (config.paths) {\n                for (prop in config.paths) {\n                    if (!(prop in empty)) {\n                        paths[prop] = config.paths[prop];\n                    }\n                }\n                context.config.paths = paths;\n            }\n\n            packagePaths = config.packagePaths;\n            if (packagePaths || config.packages) {\n                //Convert packagePaths into a packages config.\n                if (packagePaths) {\n                    for (prop in packagePaths) {\n                        if (!(prop in empty)) {\n                            configurePackageDir(packages, packagePaths[prop], prop);\n                        }\n                    }\n                }\n\n                //Adjust packages if necessary.\n                if (config.packages) {\n                    configurePackageDir(packages, config.packages);\n                }\n\n                //Done with modifications, assing packages back to context config\n                context.config.packages = packages;\n            }\n\n            //If priority loading is in effect, trigger the loads now\n            if (config.priority) {\n                //Create a separate config property that can be\n                //easily tested for config priority completion.\n                //Do this instead of wiping out the config.priority\n                //in case it needs to be inspected for debug purposes later.\n                req(config.priority);\n                context.config.priorityWait = config.priority;\n            }\n\n            //If a deps array or a config callback is specified, then call\n            //require with those args. This is useful when require is defined as a\n            //config object before require.js is loaded.\n            if (config.deps || config.callback) {\n                req(config.deps || [], config.callback);\n            }\n\n            //>>excludeStart(\"requireExcludePageLoad\", pragmas.requireExcludePageLoad);\n            //Set up ready callback, if asked. Useful when require is defined as a\n            //config object before require.js is loaded.\n            if (config.ready) {\n                req.ready(config.ready);\n            }\n            //>>excludeEnd(\"requireExcludePageLoad\");\n\n            //If it is just a config block, nothing else,\n            //then return.\n            if (!deps) {\n                return;\n            }\n        }\n\n        //Normalize dependency strings: need to determine if they have\n        //prefixes and to also normalize any relative paths. Replace the deps\n        //array of strings with an array of objects.\n        if (deps) {\n            outDeps = deps;\n            deps = [];\n            for (i = 0; i < outDeps.length; i++) {\n                deps[i] = req.splitPrefix(outDeps[i], name, context);\n            }\n        }\n\n        //Store the module for later evaluation\n        newLength = context.waiting.push({\n            name: name,\n            deps: deps,\n            callback: callback\n        });\n\n        if (name) {\n            //Store index of insertion for quick lookup\n            context.waiting[name] = newLength - 1;\n\n            //Mark the module as specified so no need to fetch it again.\n            //Important to set specified here for the\n            //pause/resume case where there are multiple modules in a file.\n            context.specified[name] = true;\n\n            //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n            //Load any modifiers for the module.\n            mods = context.modifiers[name];\n            if (mods) {\n                req(mods, contextName);\n                deferMods = mods.__deferMods;\n                if (deferMods) {\n                    for (i = 0; i < deferMods.length; i++) {\n                        deferModArgs = deferMods[i];\n\n                        //Add the context name to the def call.\n                        lastModArg = deferModArgs[deferModArgs.length - 1];\n                        if (lastModArg === undefined) {\n                            deferModArgs[deferModArgs.length - 1] = contextName;\n                        } else if (typeof lastModArg === \"string\") {\n                            deferMods.push(contextName);\n                        }\n\n                        require.def.apply(require, deferModArgs);\n                    }\n                }\n            }\n            //>>excludeEnd(\"requireExcludeModify\");\n        }\n\n        //If the callback is not an actual function, it means it already\n        //has the definition of the module as a literal value.\n        if (name && callback && !req.isFunction(callback)) {\n            context.defined[name] = callback;\n        }\n\n        //If a pluginPrefix is available, call the plugin, or load it.\n        //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n        if (pluginPrefix) {\n            callPlugin(pluginPrefix, context, {\n                name: \"require\",\n                args: [name, deps, callback, context]\n            });\n        }\n        //>>excludeEnd(\"requireExcludePlugin\");\n\n        //Hold on to the module until a script load or other adapter has finished\n        //evaluating the whole file. This helps when a file has more than one\n        //module in it -- dependencies are not traced and fetched until the whole\n        //file is processed.\n        s.paused.push([pluginPrefix, name, deps, context]);\n\n        //Set loaded here for modules that are also loaded\n        //as part of a layer, where onScriptLoad is not fired\n        //for those cases. Do this after the inline define and\n        //dependency tracing is done.\n        if (name) {\n            context.loaded[name] = true;\n        }\n    };\n\n    /**\n     * Simple function to mix in properties from source into target,\n     * but only if target does not already have a property of the same name.\n     */\n    req.mixin = function (target, source, force) {\n        for (var prop in source) {\n            if (!(prop in empty) && (!(prop in target) || force)) {\n                target[prop] = source[prop];\n            }\n        }\n        return req;\n    };\n\n    req.version = version;\n\n    //Set up page state.\n    s = req.s = {\n        ctxName: defContextName,\n        contexts: {},\n        paused: [],\n        //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n        plugins: {\n            defined: {},\n            callbacks: {},\n            waiting: {}\n        },\n        //>>excludeEnd(\"requireExcludePlugin\");\n        //Stores a list of URLs that should not get async script tag treatment.\n        skipAsync: {},\n        isBrowser: isBrowser,\n        isPageLoaded: !isBrowser,\n        readyCalls: [],\n        doc: isBrowser ? document : null\n    };\n\n    req.isBrowser = s.isBrowser;\n    if (isBrowser) {\n        s.head = document.getElementsByTagName(\"head\")[0];\n        //If BASE tag is in play, using appendChild is a problem for IE6.\n        //When that browser dies, this can be removed. Details in this jQuery bug:\n        //http://dev.jquery.com/ticket/2709\n        baseElement = document.getElementsByTagName(\"base\")[0];\n        if (baseElement) {\n            s.head = baseElement.parentNode;\n        }\n    }\n\n    //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n    /**\n     * Sets up a plugin callback name. Want to make it easy to test if a plugin\n     * needs to be called for a certain lifecycle event by testing for\n     * if (s.plugins.onLifeCyleEvent) so only define the lifecycle event\n     * if there is a real plugin that registers for it.\n     */\n    function makePluginCallback(name, returnOnTrue) {\n        var cbs = s.plugins.callbacks[name] = [];\n        s.plugins[name] = function () {\n            for (var i = 0, cb; (cb = cbs[i]); i++) {\n                if (cb.apply(null, arguments) === true && returnOnTrue) {\n                    return true;\n                }\n            }\n            return false;\n        };\n    }\n\n    /**\n     * Registers a new plugin for require.\n     */\n    req.plugin = function (obj) {\n        var i, prop, call, prefix = obj.prefix, cbs = s.plugins.callbacks,\n            waiting = s.plugins.waiting[prefix], generics,\n            defined = s.plugins.defined, contexts = s.contexts, context;\n\n        //Do not allow redefinition of a plugin, there may be internal\n        //state in the plugin that could be lost.\n        if (defined[prefix]) {\n            return req;\n        }\n\n        //Save the plugin.\n        defined[prefix] = obj;\n\n        //Set up plugin callbacks for methods that need to be generic to\n        //require, for lifecycle cases where it does not care about a particular\n        //plugin, but just that some plugin work needs to be done.\n        generics = [\"newContext\", \"isWaiting\", \"orderDeps\"];\n        for (i = 0; (prop = generics[i]); i++) {\n            if (!s.plugins[prop]) {\n                makePluginCallback(prop, prop === \"isWaiting\");\n            }\n            cbs[prop].push(obj[prop]);\n        }\n\n        //Call newContext for any contexts that were already created.\n        if (obj.newContext) {\n            for (prop in contexts) {\n                if (!(prop in empty)) {\n                    context = contexts[prop];\n                    obj.newContext(context);\n                }\n            }\n        }\n\n        //If there are waiting requests for a plugin, execute them now.\n        if (waiting) {\n            for (i = 0; (call = waiting[i]); i++) {\n                if (obj[call.name]) {\n                    obj[call.name].apply(null, call.args);\n                }\n            }\n            delete s.plugins.waiting[prefix];\n        }\n\n        return req;\n    };\n    //>>excludeEnd(\"requireExcludePlugin\");\n\n    /**\n     * Internal method used by environment adapters to complete a load event.\n     * A load event could be a script load or just a load pass from a synchronous\n     * load call.\n     * @param {String} moduleName the name of the module to potentially complete.\n     * @param {Object} context the context object\n     */\n    req.completeLoad = function (moduleName, context) {\n        //If there is a waiting require.def call\n        var args;\n        while (defQueue.length) {\n            args = defQueue.shift();\n            if (args[0] === null) {\n                args[0] = moduleName;\n                break;\n            } else if (args[0] === moduleName) {\n                //Found matching require.def call for this script!\n                break;\n            } else {\n                //Some other named require.def call, most likely the result\n                //of a build layer that included many require.def calls.\n                callDefMain(args, context);\n            }\n        }\n        if (args) {\n            callDefMain(args, context);\n        }\n\n        //Mark the script as loaded. Note that this can be different from a\n        //moduleName that maps to a require.def call. This line is important\n        //for traditional browser scripts.\n        context.loaded[moduleName] = true;\n        \n        context.scriptCount -= 1;\n        resume(context);\n    };\n\n    /**\n     * Legacy function, remove at some point\n     */\n    req.pause = req.resume = function () {};\n\n    /**\n     * Trace down the dependencies to see if they are loaded. If not, trigger\n     * the load.\n     * @param {String} pluginPrefix the plugin prefix, if any associated with the name.\n     *\n     * @param {String} name: the name of the module that has the dependencies.\n     *\n     * @param {Array} deps array of dependencies.\n     *\n     * @param {Object} context: the loading context.\n     *\n     * @private\n     */\n    req.checkDeps = function (pluginPrefix, name, deps, context) {\n        //Figure out if all the modules are loaded. If the module is not\n        //being loaded or already loaded, add it to the \"to load\" list,\n        //and request it to be loaded.\n        var i, dep;\n\n        if (pluginPrefix) {\n            //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n            callPlugin(pluginPrefix, context, {\n                name: \"checkDeps\",\n                args: [name, deps, context]\n            });\n            //>>excludeEnd(\"requireExcludePlugin\");\n        } else {\n            for (i = 0; (dep = deps[i]); i++) {\n                if (!context.specified[dep.fullName]) {\n                    context.specified[dep.fullName] = true;\n\n                    //Reset the start time to use for timeouts\n                    context.startTime = (new Date()).getTime();\n\n                    //If a plugin, call its load method.\n                    if (dep.prefix) {\n                        //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n                        callPlugin(dep.prefix, context, {\n                            name: \"load\",\n                            args: [dep.name, context.contextName]\n                        });\n                        //>>excludeEnd(\"requireExcludePlugin\");\n                    } else {\n                        req.load(dep.name, context.contextName);\n                    }\n                }\n            }\n        }\n    };\n\n    //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n    /**\n     * Register a module that modifies another module. The modifier will\n     * only be called once the target module has been loaded.\n     *\n     * First syntax:\n     *\n     * require.modify({\n     *     \"some/target1\": \"my/modifier1\",\n     *     \"some/target2\": \"my/modifier2\",\n     * });\n     *\n     * With this syntax, the my/modifier1 will only be loaded when\n     * \"some/target1\" is loaded.\n     *\n     * Second syntax, defining a modifier.\n     *\n     * require.modify(\"some/target1\", \"my/modifier\",\n     *                        [\"some/target1\", \"some/other\"],\n     *                        function (target, other) {\n     *                            //Modify properties of target here.\n     *                            Only properties of target can be modified, but\n     *                            target cannot be replaced.\n     *                        }\n     * );\n     */\n    req.modify = function (target, name, deps, callback, contextName) {\n        var prop, modifier, list,\n                cName = (typeof target === \"string\" ? contextName : name) || s.ctxName,\n                context = s.contexts[cName],\n                mods = context.modifiers;\n\n        if (typeof target === \"string\") {\n            //A modifier module.\n            //First store that it is a modifier.\n            list = mods[target] || (mods[target] = []);\n            if (!list[name]) {\n                list.push(name);\n                list[name] = true;\n            }\n\n            //Trigger the normal module definition logic if the target\n            //is already in the system.\n            if (context.specified[target]) {\n                req.def(name, deps, callback, contextName);\n            } else {\n                //Hold on to the execution/dependency checks for the modifier\n                //until the target is fetched.\n                (list.__deferMods || (list.__deferMods = [])).push([name, deps, callback, contextName]);\n            }\n        } else {\n            //A list of modifiers. Save them for future reference.\n            for (prop in target) {\n                if (!(prop in empty)) {\n                    //Store the modifier for future use.\n                    modifier = target[prop];\n                    list = mods[prop] || (context.modifiers[prop] = []);\n                    if (!list[modifier]) {\n                        list.push(modifier);\n                        list[modifier] = true;\n\n                        if (context.specified[prop]) {\n                            //Load the modifier right away.\n                            req([modifier], cName);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    //>>excludeEnd(\"requireExcludeModify\");\n\n    req.isArray = function (it) {\n        return ostring.call(it) === \"[object Array]\";\n    };\n\n    req.isFunction = isFunction;\n\n    /**\n     * Gets one module\'s exported value. This method is used by require().\n     * It is broken out as a separate function to allow a host environment\n     * shim to overwrite this function with something appropriate for that\n     * environment.\n     *\n     * @param {String} moduleName the name of the module.\n     * @param {String} [contextName] the name of the context to use. Uses\n     * default context if no contextName is provided. You should never\n     * pass the contextName explicitly -- it is handled by the require() code.\n     * @param {String} [relModuleName] a module name to use for relative\n     * module name lookups. You should never pass this argument explicitly --\n     * it is handled by the require() code.\n     *\n     * @returns {Object} the exported module value.\n     */\n    req.get = function (moduleName, contextName, relModuleName) {\n        if (moduleName === \"require\" || moduleName === \"exports\" || moduleName === \"module\") {\n            req.onError(new Error(\"Explicit require of \" + moduleName + \" is not allowed.\"));\n        }\n        contextName = contextName || s.ctxName;\n\n        var ret, context = s.contexts[contextName];\n\n        //Normalize module name, if it contains . or ..\n        moduleName = req.normalizeName(moduleName, relModuleName, context);\n\n        ret = context.defined[moduleName];\n        if (ret === undefined) {\n            req.onError(new Error(\"require: module name \'\" +\n                        moduleName +\n                        \"\' has not been loaded yet for context: \" +\n                        contextName));\n        }\n        return ret;\n    };\n\n    /**\n     * Makes the request to load a module. May be an async load depending on\n     * the environment and the circumstance of the load call. Override this\n     * method in a host environment shim to do something specific for that\n     * environment.\n     *\n     * @param {String} moduleName the name of the module.\n     * @param {String} contextName the name of the context to use.\n     */\n    req.load = function (moduleName, contextName) {\n        var context = s.contexts[contextName],\n            urlFetched = context.urlFetched,\n            loaded = context.loaded, url;\n        s.isDone = false;\n\n        //Only set loaded to false for tracking if it has not already been set.\n        if (!loaded[moduleName]) {\n            loaded[moduleName] = false;\n        }\n\n        if (contextName !== s.ctxName) {\n            //Not in the right context now, hold on to it until\n            //the current context finishes all its loading.\n            contextLoads.push(arguments);\n        } else {\n            //First derive the path name for the module.\n            url = req.nameToUrl(moduleName, null, contextName);\n            if (!urlFetched[url]) {\n                context.scriptCount += 1;\n                req.attach(url, contextName, moduleName);\n                urlFetched[url] = true;\n            }\n        }\n    };\n\n    req.jsExtRegExp = /\\.js$/;\n\n    \n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @param {Object} context\n     * @returns {String} normalized name\n     */\n    req.normalizeName = function (name, baseName, context) {\n        //Adjust any relative paths.\n        var part;\n        if (name.charAt(0) === \".\") {\n            if (!baseName) {\n                req.onError(new Error(\"Cannot normalize module name: \" +\n                            name +\n                            \", no relative module name available.\"));\n            }\n\n            if (context.config.packages[baseName]) {\n                //If the baseName is a package name, then just treat it as one\n                //name to concat the name with.\n                baseName = [baseName];\n            } else {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName\'s\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseName = baseName.split(\"/\");\n                baseName = baseName.slice(0, baseName.length - 1);\n            }\n\n            name = baseName.concat(name.split(\"/\"));\n            for (i = 0; (part = name[i]); i++) {\n                if (part === \".\") {\n                    name.splice(i, 1);\n                    i -= 1;\n                } else if (part === \"..\") {\n                    name.splice(i - 1, 2);\n                    i -= 2;\n                }\n            }\n            name = name.join(\"/\");\n        }\n        return name;\n    };\n\n    /**\n     * Splits a name into a possible plugin prefix and\n     * the module name. If baseName is provided it will\n     * also normalize the name via require.normalizeName()\n     * \n     * @param {String} name the module name\n     * @param {String} [baseName] base name that name is\n     * relative to.\n     * @param {Object} context\n     *\n     * @returns {Object} with properties, \'prefix\' (which\n     * may be null), \'name\' and \'fullName\', which is a combination\n     * of the prefix (if it exists) and the name.\n     */\n    req.splitPrefix = function (name, baseName, context) {\n        var index = name.indexOf(\"!\"), prefix = null;\n        if (index !== -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n\n        //Account for relative paths if there is a base name.\n        name = req.normalizeName(name, baseName, context);\n\n        return {\n            prefix: prefix,\n            name: name,\n            fullName: prefix ? prefix + \"!\" + name : name\n        };\n    };\n\n    /**\n     * Converts a module name to a file path.\n     */\n    req.nameToUrl = function (moduleName, ext, contextName, relModuleName) {\n        var paths, packages, pkg, pkgPath, syms, i, parentModule, url,\n            context = s.contexts[contextName],\n            config = context.config;\n\n        //Normalize module name if have a base relative module name to work from.\n        moduleName = req.normalizeName(moduleName, relModuleName, context);\n\n        //If a colon is in the URL, it indicates a protocol is used and it is just\n        //an URL to a file, or if it starts with a slash or ends with .js, it is just a plain file.\n        //The slash is important for protocol-less URLs as well as full paths.\n        if (moduleName.indexOf(\":\") !== -1 || moduleName.charAt(0) === \'/\' || req.jsExtRegExp.test(moduleName)) {\n            //Just a plain path, not module name lookup, so just return it.\n            //Add extension if it is included. This is a bit wonky, only non-.js things pass\n            //an extension, this method probably needs to be reworked.\n            return moduleName + (ext ? ext : \"\");\n        } else if (moduleName.charAt(0) === \".\") {\n            return req.onError(new Error(\"require.nameToUrl does not handle relative module names (ones that start with \'.\' or \'..\')\"));\n        } else {\n            //A module that needs to be converted to a path.\n            paths = config.paths;\n            packages = config.packages;\n\n            syms = moduleName.split(\"/\");\n            //For each module name segment, see if there is a path\n            //registered for it. Start with most specific name\n            //and work up from it.\n            for (i = syms.length; i > 0; i--) {\n                parentModule = syms.slice(0, i).join(\"/\");\n                if (paths[parentModule]) {\n                    syms.splice(0, i, paths[parentModule]);\n                    break;\n                } else if ((pkg = packages[parentModule])) {\n                    //pkg can have just a string value to the path\n                    //or can be an object with props:\n                    //main, lib, name, location.\n                    pkgPath = pkg.location + \'/\' + pkg.lib;\n                    //If module name is just the package name, then looking\n                    //for the main module.\n                    if (moduleName === pkg.name) {\n                        pkgPath += \'/\' + pkg.main;\n                    }\n                    syms.splice(0, i, pkgPath);\n                    break;\n                }\n            }\n\n            //Join the path parts together, then figure out if baseUrl is needed.\n            url = syms.join(\"/\") + (ext || \".js\");\n            return ((url.charAt(0) === \'/\' || url.match(/^\\w+:/)) ? \"\" : config.baseUrl) + url;\n        }\n    };\n\n    /**\n     * Checks if all modules for a context are loaded, and if so, evaluates the\n     * new ones in right dependency order.\n     *\n     * @private\n     */\n    req.checkLoaded = function (contextName) {\n        var context = s.contexts[contextName || s.ctxName],\n                waitInterval = context.config.waitSeconds * 1000,\n                //It is possible to disable the wait interval by using waitSeconds of 0.\n                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),\n                loaded, defined = context.defined,\n                modifiers = context.modifiers, waiting, noLoads = \"\",\n                hasLoadedProp = false, stillLoading = false, prop, priorityDone,\n                priorityName,\n\n                //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n                pIsWaiting = s.plugins.isWaiting, pOrderDeps = s.plugins.orderDeps,\n                //>>excludeEnd(\"requireExcludePlugin\");\n\n                i, module, allDone, loads, loadArgs, err;\n\n        //If already doing a checkLoaded call,\n        //then do not bother checking loaded state.\n        if (context.isCheckLoaded) {\n            return;\n        }\n\n        //Determine if priority loading is done. If so clear the priority. If\n        //not, then do not check\n        if (context.config.priorityWait) {\n            priorityDone = true;\n            for (i = 0; (priorityName = context.config.priorityWait[i]); i++) {\n                if (!context.loaded[priorityName]) {\n                    priorityDone = false;\n                    break;\n                }\n            }\n            if (priorityDone) {\n                //Clean up priority and call resume, since it could have\n                //some waiting dependencies to trace.\n                delete context.config.priorityWait;\n                resume(context);\n            } else {\n                return;\n            }\n        }\n\n        //Signal that checkLoaded is being require, so other calls that could be triggered\n        //by calling a waiting callback that then calls require and then this function\n        //should not proceed. At the end of this function, if there are still things\n        //waiting, then checkLoaded will be called again.\n        context.isCheckLoaded = true;\n\n        //Grab waiting and loaded lists here, since it could have changed since\n        //this function was first called.\n        waiting = context.waiting;\n        loaded = context.loaded;\n\n        //See if anything is still in flight.\n        for (prop in loaded) {\n            if (!(prop in empty)) {\n                hasLoadedProp = true;\n                if (!loaded[prop]) {\n                    if (expired) {\n                        noLoads += prop + \" \";\n                    } else {\n                        stillLoading = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        //Check for exit conditions.\n        if (!hasLoadedProp && !waiting.length\n            //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n            && (!pIsWaiting || !pIsWaiting(context))\n            //>>excludeEnd(\"requireExcludePlugin\");\n           ) {\n            //If the loaded object had no items, then the rest of\n            //the work below does not need to be done.\n            context.isCheckLoaded = false;\n            return;\n        }\n        if (expired && noLoads) {\n            //If wait time expired, throw error of unloaded modules.\n            err = new Error(\"require.js load timeout for modules: \" + noLoads);\n            err.requireType = \"timeout\";\n            err.requireModules = noLoads;\n            req.onError(err);\n        }\n        if (stillLoading) {\n            //Something is still waiting to load. Wait for it.\n            context.isCheckLoaded = false;\n            if (isBrowser || isWebWorker) {\n                setTimeout(function () {\n                    req.checkLoaded(contextName);\n                }, 50);\n            }\n            return;\n        }\n\n        //Order the dependencies. Also clean up state because the evaluation\n        //of modules might create new loading tasks, so need to reset.\n        //Be sure to call plugins too.\n        context.waiting = [];\n        context.loaded = {};\n\n        //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n        //Call plugins to order their dependencies, do their\n        //module definitions.\n        if (pOrderDeps) {\n            pOrderDeps(context);\n        }\n        //>>excludeEnd(\"requireExcludePlugin\");\n\n        //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n        //Before defining the modules, give priority treatment to any modifiers\n        //for modules that are already defined.\n        for (prop in modifiers) {\n            if (!(prop in empty)) {\n                if (defined[prop]) {\n                    req.execModifiers(prop, {}, waiting, context);\n                }\n            }\n        }\n        //>>excludeEnd(\"requireExcludeModify\");\n\n        //Define the modules, doing a depth first search.\n        for (i = 0; (module = waiting[i]); i++) {\n            req.exec(module, {}, waiting, context);\n        }\n\n        //Indicate checkLoaded is now done.\n        context.isCheckLoaded = false;\n\n        if (context.waiting.length\n            //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n            || (pIsWaiting && pIsWaiting(context))\n            //>>excludeEnd(\"requireExcludePlugin\");\n           ) {\n            //More things in this context are waiting to load. They were probably\n            //added while doing the work above in checkLoaded, calling module\n            //callbacks that triggered other require calls.\n            req.checkLoaded(contextName);\n        } else if (contextLoads.length) {\n            //Check for other contexts that need to load things.\n            //First, make sure current context has no more things to\n            //load. After defining the modules above, new require calls\n            //could have been made.\n            loaded = context.loaded;\n            allDone = true;\n            for (prop in loaded) {\n                if (!(prop in empty)) {\n                    if (!loaded[prop]) {\n                        allDone = false;\n                        break;\n                    }\n                }\n            }\n\n            if (allDone) {\n                s.ctxName = contextLoads[0][1];\n                loads = contextLoads;\n                //Reset contextLoads in case some of the waiting loads\n                //are for yet another context.\n                contextLoads = [];\n                for (i = 0; (loadArgs = loads[i]); i++) {\n                    req.load.apply(req, loadArgs);\n                }\n            }\n        } else {\n            //Make sure we reset to default context.\n            s.ctxName = defContextName;\n            s.isDone = true;\n            if (req.callReady) {\n                req.callReady();\n            }\n        }\n    };\n\n    /**\n     * Helper function that creates a setExports function for a \"module\"\n     * CommonJS dependency. Do this here to avoid creating a closure that\n     * is part of a loop in require.exec.\n     */\n    function makeSetExports(moduleObj) {\n        return function (exports) {\n            moduleObj.exports = exports;\n        };\n    }\n\n    function makeContextModuleFunc(name, contextName, moduleName) {\n        return function () {\n            //A version of a require function that forces a contextName value\n            //and also passes a moduleName value for items that may need to\n            //look up paths relative to the moduleName\n            var args = [].concat(aps.call(arguments, 0));\n            args.push(contextName, moduleName);\n            return (name ? require[name] : require).apply(null, args);\n        };\n    }\n\n    /**\n     * Helper function that creates a require function object to give to\n     * modules that ask for it as a dependency. It needs to be specific\n     * per module because of the implication of path mappings that may\n     * need to be relative to the module name.\n     */\n    function makeRequire(context, moduleName) {\n        var contextName = context.contextName,\n            modRequire = makeContextModuleFunc(null, contextName, moduleName);\n\n        req.mixin(modRequire, {\n            //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n            modify: makeContextModuleFunc(\"modify\", contextName, moduleName),\n            //>>excludeEnd(\"requireExcludeModify\");\n            def: makeContextModuleFunc(\"def\", contextName, moduleName),\n            get: makeContextModuleFunc(\"get\", contextName, moduleName),\n            nameToUrl: makeContextModuleFunc(\"nameToUrl\", contextName, moduleName),\n            ready: req.ready,\n            context: context,\n            config: context.config,\n            isBrowser: s.isBrowser\n        });\n        return modRequire;\n    }\n\n    /**\n     * Executes the modules in the correct order.\n     * \n     * @private\n     */\n    req.exec = function (module, traced, waiting, context) {\n        //Some modules are just plain script files, abddo not have a formal\n        //module definition, \n        if (!module) {\n            //Returning undefined for Spidermonky strict checking in Komodo\n            return undefined;\n        }\n\n        var name = module.name, cb = module.callback, deps = module.deps, j, dep,\n            defined = context.defined, ret, args = [], depModule, cjsModule,\n            usingExports = false, depName;\n\n        //If already traced or defined, do not bother a second time.\n        if (name) {\n            if (traced[name] || name in defined) {\n                return defined[name];\n            }\n\n            //Mark this module as being traced, so that it is not retraced (as in a circular\n            //dependency)\n            traced[name] = true;\n        }\n\n        if (deps) {\n            for (j = 0; (dep = deps[j]); j++) {\n                depName = dep.name;\n                if (depName === \"require\") {\n                    depModule = makeRequire(context, name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    depModule = defined[name] = {};\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = depModule = {\n                        id: name,\n                        uri: name ? req.nameToUrl(name, null, context.contextName) : undefined\n                    };\n                    cjsModule.setExports = makeSetExports(cjsModule);\n                } else {\n                    //Get dependent module. It could not exist, for a circular\n                    //dependency or if the loaded dependency does not actually call\n                    //require. Favor not throwing an error here if undefined because\n                    //we want to allow code that does not use require as a module\n                    //definition framework to still work -- allow a web site to\n                    //gradually update to contained modules. That is more\n                    //important than forcing a throw for the circular dependency case.\n                    depModule = depName in defined ? defined[depName] : (traced[depName] ? undefined : req.exec(waiting[waiting[depName]], traced, waiting, context));\n                }\n\n                args.push(depModule);\n            }\n        }\n\n        //Call the callback to define the module, if necessary.\n        cb = module.callback;\n        if (cb && req.isFunction(cb)) {\n            ret = req.execCb(name, cb, args);\n            if (name) {\n                //If using exports and the function did not return a value,\n                //and the \"module\" object for this definition function did not\n                //define an exported value, then use the exports object.\n                if (usingExports && ret === undefined && (!cjsModule || !(\"exports\" in cjsModule))) {\n                    ret = defined[name];\n                } else {\n                    if (cjsModule && \"exports\" in cjsModule) {\n                        ret = defined[name] = cjsModule.exports;\n                    } else {\n                        if (name in defined && !usingExports) {\n                            req.onError(new Error(name + \" has already been defined\"));\n                        }\n                        defined[name] = ret;\n                    }\n                }\n            }\n        }\n\n        //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n        //Execute modifiers, if they exist.\n        req.execModifiers(name, traced, waiting, context);\n        //>>excludeEnd(\"requireExcludeModify\");\n\n        return ret;\n    };\n\n    /**\n     * Executes a module callack function. Broken out as a separate function\n     * solely to allow the build system to sequence the files in the built\n     * layer in the right sequence.\n     * @param {String} name the module name.\n     * @param {Function} cb the module callback/definition function.\n     * @param {Array} args The arguments (dependent modules) to pass to callback.\n     *\n     * @private\n     */\n    req.execCb = function (name, cb, args) {\n        return cb.apply(null, args);\n    };\n\n    //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n    /**\n     * Executes modifiers for the given module name.\n     * @param {String} target\n     * @param {Object} traced\n     * @param {Object} context\n     *\n     * @private\n     */\n    req.execModifiers = function (target, traced, waiting, context) {\n        var modifiers = context.modifiers, mods = modifiers[target], mod, i;\n        if (mods) {\n            for (i = 0; i < mods.length; i++) {\n                mod = mods[i];\n                //Not all modifiers define a module, they might collect other modules.\n                //If it is just a collection it will not be in waiting.\n                if (mod in waiting) {\n                    req.exec(waiting[waiting[mod]], traced, waiting, context);\n                }\n            }\n            delete modifiers[target];\n        }\n    };\n    //>>excludeEnd(\"requireExcludeModify\");\n\n    /**\n     * callback for script loads, used to check status of loading.\n     *\n     * @param {Event} evt the event from the browser for the script\n     * that was loaded.\n     *\n     * @private\n     */\n    req.onScriptLoad = function (evt) {\n        //Using currentTarget instead of target for Firefox 2.0\'s sake. Not\n        //all old browsers will be supported, but this one was easy enough\n        //to support and still makes sense.\n        var node = evt.currentTarget || evt.srcElement, contextName, moduleName,\n            context;\n        if (evt.type === \"load\" || readyRegExp.test(node.readyState)) {\n            //Pull out the name of the module and the context.\n            contextName = node.getAttribute(\"data-requirecontext\");\n            moduleName = node.getAttribute(\"data-requiremodule\");\n            context = s.contexts[contextName];\n\n            req.completeLoad(moduleName, context);\n\n            //Clean up script binding.\n            if (node.removeEventListener) {\n                node.removeEventListener(\"load\", req.onScriptLoad, false);\n            } else {\n                //Probably IE. If not it will throw an error, which will be\n                //useful to know.\n                node.detachEvent(\"onreadystatechange\", req.onScriptLoad);\n            }\n        }\n    };\n\n    /**\n     * Attaches the script represented by the URL to the current\n     * environment. Right now only supports browser loading,\n     * but can be redefined in other environments to do the right thing.\n     * @param {String} url the url of the script to attach.\n     * @param {String} contextName the name of the context that wants the script.\n     * @param {moduleName} the name of the module that is associated with the script.\n     * @param {Function} [callback] optional callback, defaults to require.onScriptLoad\n     * @param {String} [type] optional type, defaults to text/javascript\n     */\n    req.attach = function (url, contextName, moduleName, callback, type) {\n        var node, loaded, context;\n        if (isBrowser) {\n            //In the browser so use a script tag\n            callback = callback || req.onScriptLoad;\n            node = document.createElement(\"script\");\n            node.type = type || \"text/javascript\";\n            node.charset = \"utf-8\";\n            //Use async so Gecko does not block on executing the script if something\n            //like a long-polling comet tag is being run first. Gecko likes\n            //to evaluate scripts in DOM order, even for dynamic scripts.\n            //It will fetch them async, but only evaluate the contents in DOM\n            //order, so a long-polling script tag can delay execution of scripts\n            //after it. But telling Gecko we expect async gets us the behavior\n            //we want -- execute it whenever it is finished downloading. Only\n            //Helps Firefox 3.6+\n            //Allow some URLs to not be fetched async. Mostly helps the order!\n            //plugin\n            if (!s.skipAsync[url]) {\n                node.async = true;\n            }\n            node.setAttribute(\"data-requirecontext\", contextName);\n            node.setAttribute(\"data-requiremodule\", moduleName);\n\n            //Set up load listener.\n            if (node.addEventListener) {\n                node.addEventListener(\"load\", callback, false);\n            } else {\n                //Probably IE. If not it will throw an error, which will be\n                //useful to know. IE (at least 6-8) do not fire\n                //script onload right after executing the script, so\n                //we cannot tie the anonymous require.def call to a name.\n                //However, IE reports the script as being in \"interactive\"\n                //readyState at the time of the require.def call.\n                useInteractive = true;\n                node.attachEvent(\"onreadystatechange\", callback);\n            }\n            node.src = url;\n\n            //For some cache cases in IE 6-8, the script executes before the end\n            //of the appendChild execution, so to tie an anonymous require.def\n            //call to the module name (which is stored on the node), hold on\n            //to a reference to this node, but clear after the DOM insertion.\n            currentlyAddingScript = node;\n            if (baseElement) {\n                s.head.insertBefore(node, baseElement);\n            } else {\n                s.head.appendChild(node);\n            }\n            currentlyAddingScript = null;\n            return node;\n        } else if (isWebWorker) {\n            //In a web worker, use importScripts. This is not a very\n            //efficient use of importScripts, importScripts will block until\n            //its script is downloaded and evaluated. However, if web workers\n            //are in play, the expectation that a build has been done so that\n            //only one script needs to be loaded anyway. This may need to be\n            //reevaluated if other use cases become common.\n            context = s.contexts[contextName];\n            loaded = context.loaded;\n            loaded[moduleName] = false;\n            importScripts(url);\n\n            //Account for anonymous modules\n            req.completeLoad(moduleName, context);\n        }\n        return null;\n    };\n\n    //Determine what baseUrl should be if not already defined via a require config object\n    s.baseUrl = cfg.baseUrl;\n    if (isBrowser && (!s.baseUrl || !s.head)) {\n        //Figure out baseUrl. Get it from the script tag with require.js in it.\n        scripts = document.getElementsByTagName(\"script\");\n        if (cfg.baseUrlMatch) {\n            rePkg = cfg.baseUrlMatch;\n        } else {\n            //>>includeStart(\"jquery\", pragmas.jquery);\n            rePkg = /(requireplugins-|require-)?jquery[\\-\\d\\.]*(min)?\\.js(\\W|$)/i;\n            //>>includeEnd(\"jquery\");\n\n            //>>includeStart(\"dojoConvert\", pragmas.dojoConvert);\n            rePkg = /dojo\\.js(\\W|$)/i;\n            //>>includeEnd(\"dojoConvert\");\n\n            //>>excludeStart(\"dojoConvert\", pragmas.dojoConvert);\n\n            //>>excludeStart(\"jquery\", pragmas.jquery);\n            rePkg = /(allplugins-|transportD-)?require\\.js(\\W|$)/i;\n            //>>excludeEnd(\"jquery\");\n\n            //>>excludeEnd(\"dojoConvert\");\n        }\n\n        for (i = scripts.length - 1; i > -1 && (script = scripts[i]); i--) {\n            //Set the \"head\" where we can append children by\n            //using the script\'s parent.\n            if (!s.head) {\n                s.head = script.parentNode;\n            }\n\n            //Look for a data-main attribute to set main script for the page\n            //to load.\n            if (!cfg.deps) {\n                dataMain = script.getAttribute(\'data-main\');\n                if (dataMain) {\n                    cfg.deps = [dataMain];\n                }\n            }\n\n            //Using .src instead of getAttribute to get an absolute URL.\n            //While using a relative URL will be fine for script tags, other\n            //URLs used for text! resources that use XHR calls might benefit\n            //from an absolute URL.\n            src = script.src;\n            if (src && !s.baseUrl) {\n                m = src.match(rePkg);\n                if (m) {\n                    s.baseUrl = src.substring(0, m.index);\n                    break;\n                }\n            }\n        }\n    }\n\n    //>>excludeStart(\"requireExcludePageLoad\", pragmas.requireExcludePageLoad);\n    //****** START page load functionality ****************\n    /**\n     * Sets the page as loaded and triggers check for all modules loaded.\n     */\n    req.pageLoaded = function () {\n        if (!s.isPageLoaded) {\n            s.isPageLoaded = true;\n            if (scrollIntervalId) {\n                clearInterval(scrollIntervalId);\n            }\n\n            //Part of a fix for FF < 3.6 where readyState was not set to\n            //complete so libraries like jQuery that check for readyState\n            //after page load where not getting initialized correctly.\n            //Original approach suggested by Andrea Giammarchi:\n            //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n            //see other setReadyState reference for the rest of the fix.\n            if (setReadyState) {\n                document.readyState = \"complete\";\n            }\n\n            req.callReady();\n        }\n    };\n\n    /**\n     * Internal function that calls back any ready functions. If you are\n     * integrating RequireJS with another library without require.ready support,\n     * you can define this method to call your page ready code instead.\n     */\n    req.callReady = function () {\n        var callbacks = s.readyCalls, i, callback;\n\n        if (s.isPageLoaded && s.isDone && callbacks.length) {\n            s.readyCalls = [];\n            for (i = 0; (callback = callbacks[i]); i++) {\n                callback();\n            }\n        }\n    };\n\n    /**\n     * Registers functions to call when the page is loaded\n     */\n    req.ready = function (callback) {\n        if (s.isPageLoaded && s.isDone) {\n            callback();\n        } else {\n            s.readyCalls.push(callback);\n        }\n        return req;\n    };\n\n    if (isBrowser) {\n        if (document.addEventListener) {\n            //Standards. Hooray! Assumption here that if standards based,\n            //it knows about DOMContentLoaded.\n            document.addEventListener(\"DOMContentLoaded\", req.pageLoaded, false);\n            window.addEventListener(\"load\", req.pageLoaded, false);\n            //Part of FF < 3.6 readystate fix (see setReadyState refs for more info)\n            if (!document.readyState) {\n                setReadyState = true;\n                document.readyState = \"loading\";\n            }\n        } else if (window.attachEvent) {\n            window.attachEvent(\"onload\", req.pageLoaded);\n\n            //DOMContentLoaded approximation, as found by Diego Perini:\n            //http://javascript.nwbox.com/IEContentLoaded/\n            if (self === self.top) {\n                scrollIntervalId = setInterval(function () {\n                    try {\n                        //From this ticket:\n                        //http://bugs.dojotoolkit.org/ticket/11106,\n                        //In IE HTML Application (HTA), such as in a selenium test,\n                        //javascript in the iframe can\'t see anything outside\n                        //of it, so self===self.top is true, but the iframe is\n                        //not the top window and doScroll will be available\n                        //before document.body is set. Test document.body\n                        //before trying the doScroll trick.\n                        if (document.body) {\n                            document.documentElement.doScroll(\"left\");\n                            req.pageLoaded();\n                        }\n                    } catch (e) {}\n                }, 30);\n            }\n        }\n\n        //Check if document already complete, and if so, just trigger page load\n        //listeners. NOTE: does not work with Firefox before 3.6. To support\n        //those browsers, manually call require.pageLoaded().\n        if (document.readyState === \"complete\") {\n            req.pageLoaded();\n        }\n    }\n    //****** END page load functionality ****************\n    //>>excludeEnd(\"requireExcludePageLoad\");\n\n    //Set up default context. If require was a configuration object, use that as base config.\n    req(cfg);\n\n    //If modules are built into require.js, then need to make sure dependencies are\n    //traced. Use a setTimeout in the browser world, to allow all the modules to register\n    //themselves. In a non-browser env, assume that modules are not built into require.js,\n    //which seems odd to do on the server.\n    if (typeof setTimeout !== \"undefined\") {\n        setTimeout(function () {\n            resume(s.contexts[(cfg.context || defContextName)]);\n        }, 0);\n    }\n}());\n\n/**\n * @license RequireJS i18n Copyright (c) 2004-2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint regexp: false, nomen: false, plusplus: false */\n/*global require: false, navigator: false */\n\"use strict\";\n\n/**\n * This plugin handles i18n! prefixed modules. It does the following:\n *\n * 1) A regular module can have a dependency on an i18n bundle, but the regular\n * module does not want to specify what locale to load. So it just specifies\n * the top-level bundle, like \"i18n!nls/colors\".\n *\n * This plugin will load the i18n bundle at nls/colors, see that it is a root/master\n * bundle since it does not have a locale in its name. It will then try to find\n * the best match locale available in that master bundle, then request all the\n * locale pieces for that best match locale. For instance, if the locale is \"en-us\",\n * then the plugin will ask for the \"en-us\", \"en\" and \"root\" bundles to be loaded\n * (but only if they are specified on the master bundle).\n *\n * Once all the bundles for the locale pieces load, then it mixes in all those\n * locale pieces into each other, then finally sets the context.defined value\n * for the nls/colors bundle to be that mixed in locale.\n *\n * 2) A regular module specifies a specific locale to load. For instance,\n * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle\n * first, at nls/colors, then figure out what the best match locale is for fr-fr,\n * since maybe only fr or just root is defined for that locale. Once that best\n * fit is found, all of its locale pieces need to have their bundles loaded.\n *\n * Once all the bundles for the locale pieces load, then it mixes in all those\n * locale pieces into each other, then finally sets the context.defined value\n * for the nls/fr-fr/colors bundle to be that mixed in locale.\n */\n(function () {\n    //regexp for reconstructing the master bundle name from parts of the regexp match\n    //nlsRegExp.exec(\"foo/bar/baz/nls/en-ca/foo\") gives:\n    //[\"foo/bar/baz/nls/en-ca/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"en-ca\", \"foo\"]\n    //nlsRegExp.exec(\"foo/bar/baz/nls/foo\") gives:\n    //[\"foo/bar/baz/nls/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"foo\", \"\"]\n    //so, if match[5] is blank, it means this is the top bundle definition.\n    var nlsRegExp = /(^.*(^|\\/)nls(\\/|$))([^\\/]*)\\/?([^\\/]*)/,\n        empty = {};\n\n    function getWaiting(name, context) {\n        var nlswAry = context.nlsWaiting;\n        return nlswAry[name] ||\n               //Push a new waiting object on the nlsWaiting array, but also put\n               //a shortcut lookup by name to the object on the array.\n               (nlswAry[name] = nlswAry[(nlswAry.push({ _name: name}) - 1)]);\n    }\n\n    /**\n     * Makes sure all the locale pieces are loaded, and finds the best match\n     * for the requested locale.\n     */\n    function resolveLocale(masterName, bundle, locale, context) {\n        //Break apart the locale to get the parts.\n        var i, parts, toLoad, nlsw, loc, val, bestLoc = \"root\";\n\n        parts = locale.split(\"-\");\n\n        //Now see what bundles exist for each country/locale.\n        //Want to walk up the chain, so if locale is en-us-foo,\n        //look for en-us-foo, en-us, en, then root.\n        toLoad = [];\n\n        nlsw = getWaiting(masterName, context);\n\n        for (i = parts.length; i > -1; i--) {\n            loc = i ? parts.slice(0, i).join(\"-\") : \"root\";\n            val = bundle[loc];\n            if (val) {\n                //Store which bundle to use for the default bundle definition.\n                if (locale === context.config.locale && !nlsw._match) {\n                    nlsw._match = loc;\n                }\n\n                //Store the best match for the target locale\n                if (bestLoc === \"root\") {\n                    bestLoc = loc;\n                }\n\n                //Track that the locale needs to be resolved with its parts.\n                //Mark what locale should be used when resolving.\n                nlsw[loc] = loc;\n\n                //If locale value is true, it means it is a resource that\n                //needs to be loaded. Track it to load if it has not already\n                //been asked for.\n                if (val === true) {\n                    //split off the bundl name from master name and insert the\n                    //locale before the bundle name. So, if masterName is\n                    //some/path/nls/colors, then the locale fr-fr\'s bundle name should\n                    //be some/path/nls/fr-fr/colors\n                    val = masterName.split(\"/\");\n                    val.splice(-1, 0, loc);\n                    val = val.join(\"/\");\n\n                    if (!context.specified[val] && !(val in context.loaded) && !context.defined[val]) {\n                        context.defPlugin[val] = \'i18n\';\n                        toLoad.push(val);\n                    }\n                }\n            }\n        }\n\n        //If locale was not an exact match, store the closest match for it.\n        if (bestLoc !== locale) {\n            if (context.defined[bestLoc]) {\n                //Already got it. Easy peasy lemon squeezy.\n                context.defined[locale] = context.defined[bestLoc];\n            } else {\n                //Need to wait for things to load then define it.\n                nlsw[locale] = bestLoc;\n            }\n        }\n\n        //Load any bundles that are still needed.\n        if (toLoad.length) {\n            require(toLoad, context.contextName);\n        }\n    }\n\n    require.plugin({\n        prefix: \"i18n\",\n\n        /**\n         * This callback is prefix-specific, only gets called for this prefix\n         */\n        require: function (name, deps, callback, context) {\n            var i, match, nlsw, bundle, master, toLoad, obj = context.defined[name];\n\n            //All i18n modules must match the nls module name structure.\n            match = nlsRegExp.exec(name);\n            //If match[5] is blank, it means this is the top bundle definition,\n            //so it does not have to be handled. Only deal with ones that have a locale\n            //(a match[4] value but no match[5])\n            if (match[5]) {\n                master = match[1] + match[5];\n\n                //Track what locale bundle need to be generated once all the modules load.\n                nlsw = getWaiting(master, context);\n                nlsw[match[4]] = match[4];\n\n                bundle = context.nls[master];\n                if (!bundle) {\n                    //No master bundle yet, ask for it.\n                    context.defPlugin[master] = \'i18n\';\n                    require([master], context.contextName);\n                    bundle = context.nls[master] = {};\n                }\n                //For nls modules, the callback is just a regular object,\n                //so save it off in the bundle now.\n                bundle[match[4]] = callback;\n            } else {\n                //Integrate bundle into the nls area.\n                bundle = context.nls[name];\n                if (bundle) {\n                    //A specific locale already started the bundle object.\n                    //Do a mixin (which will not overwrite the locale property\n                    //on the bundle that has the previously loaded locale\'s info)\n                    require.mixin(bundle, obj);\n                } else {\n                    bundle = context.nls[name] = obj;\n                }\n                context.nlsRootLoaded[name] = true;\n\n                //Make sure there are no locales waiting to be resolved.\n                toLoad = context.nlsToLoad[name];\n                if (toLoad) {\n                    delete context.nlsToLoad[name];\n                    for (i = 0; i < toLoad.length; i++) {\n                        resolveLocale(name, bundle, toLoad[i], context);\n                    }\n                }\n\n                resolveLocale(name, bundle, context.config.locale, context);\n            }\n        },\n\n        /**\n         * Called when a new context is defined. Use this to store\n         * context-specific info on it.\n         */\n        newContext: function (context) {\n            require.mixin(context, {\n                nlsWaiting: [],\n                nls: {},\n                nlsRootLoaded: {},\n                nlsToLoad: {}\n            });\n            if (!context.config.locale) {\n                context.config.locale = typeof navigator === \"undefined\" ? \"root\" :\n                        (navigator.language || navigator.userLanguage || \"root\").toLowerCase();\n            }\n        },\n\n        /**\n         * Called when a dependency needs to be loaded.\n         */\n        load: function (name, contextName) {\n            //Make sure the root bundle is loaded, to check if we can support\n            //loading the requested locale, or if a different one needs\n            //to be chosen.\n            var masterName, context = require.s.contexts[contextName], bundle,\n                match = nlsRegExp.exec(name), locale = match[4];\n\n            //If match[5] is blank, it means this is the top bundle definition,\n            //so it does not have to be handled. Only deal with ones that have a locale\n            //(a match[4] value but no match[5])\n            if (match[5]) {\n                //locale-specific bundle\n                masterName = match[1] + match[5];\n                bundle = context.nls[masterName];\n                if (context.nlsRootLoaded[masterName] && bundle) {\n                    resolveLocale(masterName, bundle, locale, context);\n                } else {\n                    //Store this locale to figure out after masterName is loaded and load masterName.\n                    (context.nlsToLoad[masterName] || (context.nlsToLoad[masterName] = [])).push(locale);\n                    context.defPlugin[masterName] = \'i18n\';\n                    require([masterName], contextName);\n                }\n            } else {\n                //Top-level bundle. Just call regular load, if not already loaded\n                if (!context.nlsRootLoaded[name]) {\n                    context.defPlugin[name] = \'i18n\';\n                    require.load(name, contextName);\n                }\n            }\n        },\n\n        /**\n         * Called when the dependencies of a module are checked.\n         */\n        checkDeps: function (name, deps, context) {\n            //i18n bundles are always defined as objects for their \"dependencies\",\n            //and that object is already processed in the require method, no need to\n            //do work in here.\n        },\n\n        /**\n         * Called to determine if a module is waiting to load.\n         */\n        isWaiting: function (context) {\n            return !!context.nlsWaiting.length;\n        },\n\n        /**\n         * Called when all modules have been loaded.\n         */\n        orderDeps: function (context) {\n            //Clear up state since further processing could\n            //add more things to fetch.\n            var i, j, master, msWaiting, bundle, parts, moduleSuffix, mixed,\n                modulePrefix, loc, defLoc, locPart, nlsWaiting = context.nlsWaiting,\n                bestFit;\n            context.nlsWaiting = [];\n            context.nlsToLoad = {};\n\n            //First, properly mix in any nls bundles waiting to happen.\n            for (i = 0; (msWaiting = nlsWaiting[i]); i++) {\n                //Each property is a master bundle name.\n                master = msWaiting._name;\n                bundle = context.nls[master];\n                defLoc = null;\n\n                //Create the module name parts from the master name. So, if master\n                //is foo/nls/bar, then the parts should be prefix: \"foo/nls\",\n                // suffix: \"bar\", and the final locale\'s module name will be foo/nls/locale/bar\n                parts = master.split(\"/\");\n                modulePrefix = parts.slice(0, parts.length - 1).join(\"/\");\n                moduleSuffix = parts[parts.length - 1];\n                //Cycle through the locale props on the waiting object and combine\n                //the locales together.\n                for (loc in msWaiting) {\n                    if (loc !== \"_name\" && !(loc in empty)) {\n                        if (loc === \"_match\") {\n                            //Found default locale to use for the top-level bundle name.\n                            defLoc = msWaiting[loc];\n                        \n                        } else if (msWaiting[loc] !== loc) {\n                            //A \"best fit\" locale, store it off to the end and handle\n                            //it at the end by just assigning the best fit value, since\n                            //after this for loop, the best fit locale will be defined.\n                            (bestFit || (bestFit = {}))[loc] = msWaiting[loc];\n                        } else {\n                            //Mix in the properties of this locale together.\n                            //Split the locale into pieces.\n                            mixed = {};\n                            parts = loc.split(\"-\");\n                            for (j = parts.length; j > 0; j--) {\n                                locPart = parts.slice(0, j).join(\"-\");\n                                if (locPart !== \"root\" && bundle[locPart]) {\n                                    require.mixin(mixed, bundle[locPart]);\n                                }\n                            }\n                            if (bundle.root) {\n                                require.mixin(mixed, bundle.root);\n                            }\n\n                            context.defined[modulePrefix + \"/\" + loc + \"/\" + moduleSuffix] = mixed;\n                        }\n                    }\n                }\n\n                //Finally define the default locale. Wait to the end of the property\n                //loop above so that the default locale bundle has been properly mixed\n                //together.\n                context.defined[master] = context.defined[modulePrefix + \"/\" + defLoc + \"/\" + moduleSuffix];\n                \n                //Handle any best fit locale definitions.\n                if (bestFit) {\n                    for (loc in bestFit) {\n                        if (!(loc in empty)) {\n                            context.defined[modulePrefix + \"/\" + loc + \"/\" + moduleSuffix] = context.defined[modulePrefix + \"/\" + bestFit[loc] + \"/\" + moduleSuffix];\n                        }\n                    }\n                }\n            }\n        }\n    });\n}());\n\n/**\n * @license RequireJS text Copyright (c) 2004-2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint regexp: false, nomen: false, plusplus: false */\n/*global require: false, XMLHttpRequest: false, ActiveXObject: false */\n\"use strict\";\n\n(function () {\n    var progIds = [\'Msxml2.XMLHTTP\', \'Microsoft.XMLHTTP\', \'Msxml2.XMLHTTP.4.0\'],\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\\'\\\"](\\d)*.(\\d)*[\\\'\\\"](\\s)*\\?>/im,\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im;\n\n    if (!require.textStrip) {\n        require.textStrip = function (text) {\n            //Strips <?xml ...?> declarations so that external SVG and XML\n            //documents can be added to a document without worry. Also, if the string\n            //is an HTML document, only the part inside the body tag is returned.\n            if (text) {\n                text = text.replace(xmlRegExp, \"\");\n                var matches = text.match(bodyRegExp);\n                if (matches) {\n                    text = matches[1];\n                }\n            } else {\n                text = \"\";\n            }\n            return text;\n        };\n    }\n\n    //Upgrade require to add some methods for XHR handling. But it could be that\n    //this require is used in a non-browser env, so detect for existing method\n    //before attaching one.\n    if (!require.getXhr) {\n        require.getXhr = function () {\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\n            var xhr, i, progId;\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                return new XMLHttpRequest();\n            } else {\n                for (i = 0; i < 3; i++) {\n                    progId = progIds[i];\n                    try {\n                        xhr = new ActiveXObject(progId);\n                    } catch (e) {}\n\n                    if (xhr) {\n                        progIds = [progId];  // so faster next time\n                        break;\n                    }\n                }   \n            }\n\n            if (!xhr) {\n                throw new Error(\"require.getXhr(): XMLHttpRequest not available\");\n            }\n\n            return xhr;\n        };\n    }\n    \n    if (!require.fetchText) {\n        require.fetchText = function (url, callback) {\n            var xhr = require.getXhr();\n            xhr.open(\'GET\', url, true);\n            xhr.onreadystatechange = function (evt) {\n                //Do not explicitly handle errors, those should be\n                //visible via console output in the browser.\n                if (xhr.readyState === 4) {\n                    callback(xhr.responseText);\n                }\n            };\n            xhr.send(null);\n        };\n    }\n\n    require.plugin({\n        prefix: \"text\",\n\n        /**\n         * This callback is prefix-specific, only gets called for this prefix\n         */\n        require: function (name, deps, callback, context) {\n            //No-op, require never gets these text items, they are always\n            //a dependency, see load for the action.\n        },\n\n        /**\n         * Called when a new context is defined. Use this to store\n         * context-specific info on it.\n         */\n        newContext: function (context) {\n            require.mixin(context, {\n                text: {},\n                textWaiting: []\n            });\n        },\n\n        /**\n         * Called when a dependency needs to be loaded.\n         */\n        load: function (name, contextName) {\n            //Name has format: some.module!filext!strip!text\n            //The strip and text parts are optional.\n            //if strip is present, then that means only get the string contents\n            //inside a body tag in an HTML string. For XML/SVG content it means\n            //removing the <?xml ...?> declarations so the content can be inserted\n            //into the current doc without problems.\n            //If text is present, it is the actual text of the file.\n            var strip = false, text = null, key, url, index = name.indexOf(\".\"),\n                modName = name.substring(0, index), fullKey,\n                ext = name.substring(index + 1, name.length),\n                context = require.s.contexts[contextName],\n                tWaitAry = context.textWaiting;\n\n            index = ext.indexOf(\"!\");\n            if (index !== -1) {\n                //Pull off the strip arg.\n                strip = ext.substring(index + 1, ext.length);\n                ext = ext.substring(0, index);\n                index = strip.indexOf(\"!\");\n                if (index !== -1 && strip.substring(0, index) === \"strip\") {\n                    //Pull off the text.\n                    text = strip.substring(index + 1, strip.length);\n                    strip = \"strip\";\n                } else if (strip !== \"strip\") {\n                    //strip is actually the inlined text.\n                    text = strip;\n                    strip = null;\n                }\n            }\n            key = modName + \"!\" + ext;\n            fullKey = strip ? key + \"!\" + strip : key;\n\n            //Store off text if it is available for the given key and be done.\n            if (text !== null && !context.text[key]) {\n                context.defined[name] = context.text[key] = text;\n                return;\n            }\n\n            //If text is not available, load it.\n            if (!context.text[key] && !context.textWaiting[key] && !context.textWaiting[fullKey]) {\n                //Keep track that the fullKey needs to be resolved, during the\n                //orderDeps stage.\n                if (!tWaitAry[fullKey]) {\n                    tWaitAry[fullKey] = tWaitAry[(tWaitAry.push({\n                        name: name,\n                        key: key,\n                        fullKey: fullKey,\n                        strip: !!strip\n                    }) - 1)];\n                }\n\n                //Load the text.\n                url = require.nameToUrl(modName, \".\" + ext, contextName);\n                context.loaded[name] = false;\n                require.fetchText(url, function (text) {\n                    context.text[key] = text;\n                    context.loaded[name] = true;\n                });\n            }\n        },\n\n        /**\n         * Called when the dependencies of a module are checked.\n         */\n        checkDeps: function (name, deps, context) {\n            //No-op, checkDeps never gets these text items, they are always\n            //a dependency, see load for the action.\n        },\n\n        /**\n         * Called to determine if a module is waiting to load.\n         */\n        isWaiting: function (context) {\n            return !!context.textWaiting.length;\n        },\n\n        /**\n         * Called when all modules have been loaded.\n         */\n        orderDeps: function (context) {\n            //Clear up state since further processing could\n            //add more things to fetch.\n            var i, dep, text, tWaitAry = context.textWaiting;\n            context.textWaiting = [];\n            for (i = 0; (dep = tWaitAry[i]); i++) {\n                text = context.text[dep.key];\n                context.defined[dep.name] = dep.strip ? require.textStrip(text) : text;\n            }\n        }\n    });\n}());\n\n\n(function () {\n    /**\n * @license RequireJS Copyright (c) 2004-2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\nvar logger = {\n\tTRACE: 0,\n\tINFO: 1,\n\tWARN: 2,\n\tERROR: 3,\n\tlevel: 0,\n\tlogPrefix: \"\",\n\n\ttrace: function(message){\n\t\tif(this.level <= this.TRACE){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\tinfo: function(message){\n\t\tif(this.level <= this.INFO){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\twarn: function(message){\n\t\tif(this.level <= this.WARN){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\terror: function(message){\n\t\tif(this.level <= this.ERROR){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\t_print: function(message){\n\t\tthis._sysPrint((this.logPrefix ? (this.logPrefix + \" \") : \"\") + message);\n\t},\n\n        _sysPrint: function(message){\n            print(message);\n        }\n}\n\n/**\n * @license RequireJS Copyright (c) 2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n\n/*jslint plusplus: false, regexp: false */\n/*global Packages: false, logger: false, fileUtil: false */\n\"use strict\";\n\nvar commonJs = {\n    depRegExp: /require\\s*\\(\\s*[\"\']([\\w-_\\.\\/]+)[\"\']\\s*\\)/g,\n\n    //Set this to false in non-rhino environments. If rhino, then it uses\n    //rhino\'s decompiler to remove comments before looking for require() calls,\n    //otherwise, it will use a crude regexp approach to remove comments. The\n    //rhino way is more robust, but he regexp is more portable across environments.\n    useRhino: true,\n\n    //Set to false if you do not want this file to log. Useful in environments\n    //like node where you want the work to happen without noise.\n    useLog: true,\n\n    //Set to true to see full converted module contents logged to output.\n    logConverted: false,\n\n    convertDir: function (commonJsPath, savePath, prefix) {\n        //Normalize prefix\n        prefix = prefix ? prefix + \"/\" : \"\";\n\n        var fileList, i,\n            jsFileRegExp = /\\.js$/,\n            fileName, moduleName, convertedFileName, fileContents;\n\n        //Get list of files to convert.\n        fileList = fileUtil.getFilteredFileList(commonJsPath, /\\w/, true);\n        \n        //Normalize on front slashes and make sure the paths do not end in a slash.\n        commonJsPath = commonJsPath.replace(/\\\\/g, \"/\");\n        savePath = savePath.replace(/\\\\/g, \"/\");\n        if (commonJsPath.charAt(commonJsPath.length - 1) === \"/\") {\n            commonJsPath = commonJsPath.substring(0, commonJsPath.length - 1);\n        }\n        if (savePath.charAt(savePath.length - 1) === \"/\") {\n            savePath = savePath.substring(0, savePath.length - 1);\n        }\n\n        //Cycle through all the JS files and convert them.\n        if (!fileList || !fileList.length) {\n            if (commonJsPath === \"convert\") {\n                //A request just to convert one file.\n                logger.trace(\'\\n\\n\' + commonJs.convert(savePath, fileUtil.readFile(savePath)));\n            } else {\n                logger.error(\"No files to convert in directory: \" + commonJsPath);\n            }\n        } else {\n            for (i = 0; (fileName = fileList[i]); i++) {\n                convertedFileName = fileName.replace(commonJsPath, savePath);\n\n                //Handle JS files.\n                if (jsFileRegExp.test(fileName)) {\n                    moduleName = fileName.replace(commonJsPath + \"/\", \"\").replace(/\\.js$/, \"\");\n        \n                    fileContents = fileUtil.readFile(fileName);\n                    fileContents = commonJs.convert(prefix + moduleName, fileName, fileContents);\n                    fileUtil.saveUtf8File(convertedFileName, fileContents);\n                } else {\n                    //Just copy the file over.\n                    fileUtil.copyFile(fileName, convertedFileName, true);\n                }\n            }\n        }\n    },\n\n    /**\n     * Removes the comments from a string. Uses a more robust method if\n     * Rhino is available, otherwise a cruder regexp is used. If the regexp\n     * is used, then the contents may not be executable, but hopefully good\n     * enough to use to find require() calls.\n     * \n     * @param {String} fileContents\n     * @param {String} fileName mostly used for informative reasons if an error.\n     * \n     * @returns {String} a string of JS with comments removed.\n     */\n    removeComments: function (fileContents, fileName) {\n        var context, script;\n        if (commonJs.useRhino) {\n            context = Packages.org.mozilla.javascript.Context.enter();\n            script = context.compileString(fileContents, fileName, 1, null);\n            return String(context.decompileScript(script, 0));\n        } else {\n            return fileContents.replace(/(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg, \"\");\n        }\n    },\n\n    /**\n     * Regexp for testing if there is already a require.def call in the file,\n     * in which case do not try to convert it.\n     */\n    defRegExp: /require\\s*\\.\\s*def\\s*\\(/,\n\n    /**\n     * Regexp for testing if there is a require([]) or require(function(){})\n     * call, indicating the file is already in requirejs syntax.\n     */\n    rjsRegExp: /require\\s*\\(\\s*(\\[|function)/,\n\n    /**\n     * Does the actual file conversion.\n     *\n     * @param {String} moduleName the name of the module to use for the\n     * require.def call.\n     * \n     * @param {String} fileName the name of the file.\n     * \n     * @param {String} fileContents the contents of a file :)\n     *\n     * @returns {String} the converted contents\n     */\n    convert: function (moduleName, fileName, fileContents) {\n        //Strip out comments.\n        if (commonJs.useLog) {\n            logger.trace(\"fileName: \" + fileName);\n        }\n        try {\n            var i, deps = [], depName, origDepName, part, pathConverted = {},\n                prop, reqRegExp, match,\n                //Remove comments\n                tempContents = commonJs.removeComments(fileContents, fileName),\n                baseName = moduleName.split(\"/\");\n\n            //First see if the module is not already RequireJS-formatted.\n            if (commonJs.defRegExp.test(tempContents) || commonJs.rjsRegExp.test(tempContents)) {\n                return fileContents;\n            }\n\n            //Set baseName to be one directory higher than moduleName.\n            baseName.pop();\n    \n            //Reset the regexp to start at beginning of file. Do this\n            //since the regexp is reused across files.\n            commonJs.depRegExp.lastIndex = 0;\n\n            //Find dependencies in the code that was not in comments.\n            while ((match = commonJs.depRegExp.exec(tempContents))) {\n                depName = match[1];\n                if (commonJs.useLog) {\n                    logger.trace(\"  \" + depName);\n                }\n                if (depName) {\n                    deps.push(\'\"\' + depName + \'\"\');\n                }\n            }\n\n            //Construct the wrapper boilerplate.\n            fileContents = \'require.def([\"require\", \"exports\", \"module\"\' +\n                   (deps.length ? \', \' + deps.join(\",\") : \'\') + \'], \' +\n                   \'function(require, exports, module) {\\n\' +\n                   (commonJs.logConverted ? \'global._requirejs_logger.trace(\"Evaluating module: \' + moduleName + \'\");\\n\' : \"\") +\n                   fileContents +\n                   \'\\n});\\n\';\n        } catch (e) {\n            logger.error(\"COULD NOT CONVERT: \" + fileName + \", so skipping it. Error was: \" + e);\n            return fileContents;\n        }\n\n        if (commonJs.logConverted) {\n            logger.trace(\"\\nREQUIREJS CONVERTED MODULE: \" + moduleName + \"\\n\\n\" + fileContents + \"\\n\");\n        }\n        return fileContents;\n    }\n};\n\n\n    var natives = process.binding(\'natives\'),\n        isDebug = global.__requireIsDebug;\n\n    //TODO: make this async. Using sync now to cheat to get to a bootstrap.\n    require.load = function (moduleName, contextName) {\n        var url = require.nameToUrl(moduleName, null, contextName),\n            context = require.s.contexts[contextName],\n            content;\n\n        //isDone is used by require.ready()\n        require.s.isDone = false;\n\n        //Indicate a the module is in process of loading.\n        context.loaded[moduleName] = false;\n\n        //Load the content for the module. Be sure to first check the natives\n        //modules that are burned into node first.\n        if (natives[moduleName]) {\n            if (isDebug) {\n                logger.trace(\"RequireJS loading module: \" + moduleName + \" from Node cache\");\n            }\n\n            content = natives[moduleName];\n        } else {\n            if (isDebug) {\n                logger.trace(\"RequireJS loading module: \" + moduleName + \" at path: \" + url);\n            }\n            content = require._nodeReadFile(url);\n        }\n\n        //If a CommonJS module, translate it on the fly.\n        //The commonJs module is from build/jslib/commonJs.js\n        content = commonJs.convert(moduleName, url, content);\n\n        //TODO: remove when node code is updated:\n        //sys has an obsolete circular ref to child_process. Remove it.\n        if (moduleName === \"sys\") {\n            content = content.replace(/,\\s*\"child_process\"/, \"\");\n        }\n\n        if (isDebug) {\n            logger.trace(\"RequireJS about to evaluate module: \" + moduleName);\n        }\n        process.compile(content, url);\n\n        //Support anonymous modules.\n        require.completeLoad(moduleName, context);\n    };\n\n    //Adapter to get text plugin to work.\n    require.fetchText = function (url, callback) {\n        var content = require._nodeReadFile(url);\n        callback(content);\n    };\n\n    //Do some patch-ups\n    logger._sysPrint = global.__requireLog;\n    commonJs.useRhino = false;\n\n    //Set useLog to true if some modules do not seem to convert.\n    commonJs.useLog = false;\n    if (isDebug) {\n        commonJs.useLog = true;\n        //Uncomment to try to see converted module code, but seems to be\n        //not useful-- only prints a little bit, interferes with other output?\n        //commonJs.logConverted = true;\n        global._requirejs_logger = logger;\n    }\n\n    require._log = global.__requireLog;\n    require._nodeReadFile = global.__requireReadFile;\n\n    delete global.__requireReadFile;\n    delete global.__requireLog;\n    delete global.__requireIsDebug;\n}());\n\n\n", "requirejs/requireAdapter.js");

    //Set the baseUrl to be the app directory, and pass in the paths.
    process.compile("require({baseUrl: '" + appDir + "'});", "baseUrl");

    //Showtime!
    process.compile(fs.readFileSync(appFilePath), appFilePath);
}());
